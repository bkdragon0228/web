<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
        <style>
            .red {
                color: #ff0000;
            }
            .blue {
                color: #0000ff;
            }
            .big {
                font-size: 2rem;
            }
        </style>
    </head>
    <body>
        <div>
            <h1>bkboy</h1>
            <ul>
                <li id="one" class="red">html</li>
                <li id="two" class="red">css</li>
                <li id="three" class="red">javascipt</li>
                <li id="four">Typescript</li>
            </ul>
        </div>

        <script>
            //dom tree : dom의 모든 요소, 어트리뷰트(css속성), 텍스트는 하나의 객체이고 document 객체의 자식이다.
            // 요소의 중첩 관계는 트리로 구조화화여 부자관계를 표현한다.

            // 하나의 요소 노드 선택
            const elem = document.getElementById('one');
            elem.className = 'blue'; // 요소노드에 접근해 어트리뷰트 값을 변경했다.
            console.log(elem);

            const elem2 = document.querySelector('.blue'); // 중복시 첫번째만
            console.log(elem2);

            //여러 개의 요소 노드 선택!
            let ele = document.getElementsByClassName('red');
            // 유사배열, 실시간으로 노드의 상태변경을 반영해서 for 문을 사용하는데 에로사항이 있다.
            [...ele].forEach((el) => (el.className = 'blue'));
            // 43번줄 처럼 배열로 바꿔서 사용하면 문제가 생기지 않는다.

            console.clear();

            ele = document.querySelectorAll('.blue');
            for (let i = 0; i < ele.length; i++) {
                ele[i].className = 'red';
            } // querySelectorAll은 실시간 상태변경이 아니라 문제없이 for문 사용할 수 있다.
            // 여러 개 요소노드를 선택할 떈, querySelectorAll이 더 좋은 거 같다.

            // 탐색
            ele = document.querySelector('#two');
            console.log(ele.parentNode);

            ele = document.querySelector('ul');
            // console.log(ele.lastChild);
            // console.log(ele.fristChild); // 줄바꿈을 text노드로 인식하기떄문에 생각한 결과가 나오지 않는다.
            console.log(ele.firstElementChild);
            console.log(ele.lastElementChild);

            console.log(ele.hasChildNodes()); // true
            if (ele.hasChildNodes()) {
                console.log(ele.childNodes);
                // 모든 자식요소 반환
                console.log(`              `);
                console.log(ele.children);
                //요소 노드만 반환, live
            }

            // 조작
            // 텍스트 노드에 접근/수정
            const one = document.getElementById('one');
            console.log(one.nodeName); //li
            console.log(one.nodeType); // 1 : 요소 노드

            const textOne = one.firstChild; // 텍스트 노드에 접근
            console.log(textOne);
            textOne.nodeValue = 'C++'; // 값을 수정

            console.clear();

            // 어트리뷰트 노드에 접근/수정 (CSS속성 = 어트리뷰트)
            ele = document.querySelectorAll('li');

            for (let item of ele) {
                if ((item.className = 'red')) {
                    item.className = 'blue'; // class 어트리뷰트를 취득 or 수정
                }
                if (item.classList.contains('blue')) {
                    item.classList.add('big');
                }
            }
            ele = document.getElementById('two');
            console.log(ele.className); // blue big (공백으로 구분된 문자열, split으로 배열로 변경하여 사용가능)

            const heading = document.querySelector('h1');
            heading.id = 'title'; // id 어트리뷰트 값을 취득 or 변경해줌

            console.clear();

            // HTML 컨텐츠 조작

            const ul = document.querySelector('ul');
            console.log(ul.textContent); // 요소의 텍스트를 취득
            let ones = document.querySelector('#one');
            ones.textContent += ', c#';
            console.log(ones.textContent);

            console.log(ul.innerHTML); // 마크업(<***>) 포함 컨텐츠, 변경도 가능

            // innerHTML 프로퍼티 사용하지 않고 새로운 컨텐츠 추가하기

            const newElem = document.createElement('li');
            const newText = document.createTextNode('python');
            newElem.appendChild(newText); // 자식으로 추가하는 메서드
            newElem.innerHTML += ', <h1>python</h1>';
            const container = document.querySelector('ul');
            container.appendChild(newElem);
            //removeChild로 제거 할 수도 있다.

            // ! = 텍스트 추가, 변경시 textContent, 새로운 요소 추가,삭제 시 crateElement로 하자

            // style
        </script>
    </body>
</html>
